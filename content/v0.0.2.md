# frx v0.0.2

**frx** is a collection of Go libraries designed to provide convenient encapsulations for common development tasks. It includes non-business logic code for large-scale project development, transport frameworks and standard libraries, and useful toolkits.

The project is organized into several modules, each focusing on a specific aspect of Go development:

- **ctxcache** - Context caching for HTTP requests
- **errorx** - Comprehensive error code management
- **httpx** - Enhanced HTTP client and server wrappers
- **idgen** - Distributed unique ID generation
- **logs** - Compute logging functionality
- **lang** - Go language extension utilities

## Installation

To use frx in your Go project, you can install individual modules or the entire package:

### Install the entire package

```bash
go get github.com/crazyfrankie/frx@latest
```

## ctxcache（context caching middleware）

The ctxcache module provides thread-safe context caching for HTTP requests, enabling efficient data sharing within request lifecycles without repeated computations or database queries.

### Features

- **Thread-safe caching** using sync.Map for concurrent access
- **Generic type support** with compile-time type safety
- **Context-based lifecycle** - cache lives within request context
- **Key existence checking** with HasKey function
- **Zero-value handling** for missing keys
- **Any key type support** - strings, structs, or custom types

### Basic Usage

Initialize ctxcache as your first middleware (recommended for frameworks like Gin):

```go
func InitRouter() {
    srv := gin.Default()

    // Initialize context cache first
    srv.Use(func(c *gin.Context) {
        ctx := ctxcache.Init(c.Request.Context())
        c.Request = c.Request.WithContext(ctx)
        c.Next()
    })
    
    // Other middlewares follow
    // srv.Use(CORS())
    // srv.Use(Auth())
}
```

### Storing and Retrieving Data

```go
// Store different types of data
ctxcache.Store(ctx, "user_id", int64(12345))
ctxcache.Store(ctx, "user_name", "john_doe")
ctxcache.Store(ctx, "is_admin", true)

// Store complex structures
type User struct {
    ID   int64  `json:"id"`
    Name string `json:"name"`
}
user := User{ID: 123, Name: "John"}
ctxcache.Store(ctx, "current_user", user)

// Retrieve with type safety
userID, ok := ctxcache.Get[int64](ctx, "user_id")
if !ok {
    // Handle missing key
    return errors.New("user_id not found in cache")
}

userName, ok := ctxcache.Get[string](ctx, "user_name")
if ok {
    fmt.Printf("User: %s (ID: %d)\n", userName, userID)
}

// Retrieve complex structures
cachedUser, ok := ctxcache.Get[User](ctx, "current_user")
if ok {
    fmt.Printf("Current user: %+v\n", cachedUser)
}
```

### Advanced Usage

```go
// Using custom key types for better organization
type CacheKey struct {
    Module string
    ID     int64
}

userKey := CacheKey{Module: "user", ID: 123}
ctxcache.Store(ctx, userKey, userData)

// Check if key exists before retrieval
if ctxcache.HasKey(ctx, userKey) {
    user, _ := ctxcache.Get[User](ctx, userKey)
    // Process user data
}

// Cache expensive operations
func GetUserPermissions(ctx context.Context, userID int64) ([]string, error) {
    cacheKey := fmt.Sprintf("permissions_%d", userID)
    
    // Check cache first
    if permissions, ok := ctxcache.Get[[]string](ctx, cacheKey); ok {
        return permissions, nil
    }
    
    // Expensive database query
    permissions, err := database.GetUserPermissions(userID)
    if err != nil {
        return nil, err
    }
    
    // Cache the result
    ctxcache.Store(ctx, cacheKey, permissions)
    return permissions, nil
}
```

## httpx（enhanced HTTP client）

The httpx module provides a fluent, chainable HTTP client with enhanced functionality for building and executing HTTP requests with automatic error handling and JSON support.

### Features

- **Fluent API design** with method chaining
- **Automatic JSON handling** for request/response bodies
- **Custom HTTP client support** for advanced configurations
- **Query parameter management** with automatic URL encoding
- **Header manipulation** with multiple value support
- **Error propagation** throughout the chain
- **Context support** for request cancellation and timeouts

### Basic HTTP Operations

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"

    "github.com/crazyfrankie/frx/httpx"
)

func main() {
    ctx := context.Background()
    
    // Simple GET request
    resp := httpx.NewRequest(ctx, http.MethodGet, "https://api.example.com/users").
        AddParam("page", "1").
        AddParam("limit", "10").
        AddHeader("Authorization", "Bearer token123").
        Do()
    
    if resp.err != nil {
        panic(resp.err)
    }
    defer resp.Body.Close()
    
    fmt.Printf("Status: %d\n", resp.StatusCode)
}
```

### JSON Request/Response Handling

```go
type CreateUserRequest struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

type User struct {
    ID    int64  `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

func CreateUser(ctx context.Context, req CreateUserRequest) (*User, error) {
    var user User
    
    resp := httpx.NewRequest(ctx, http.MethodPost, "https://api.example.com/users").
        AddHeader("Content-Type", "application/json").
        AddHeader("Authorization", "Bearer token123").
        JSONBody(req).  // Automatically marshals to JSON
        Do()
    
    if resp.err != nil {
        return nil, resp.err
    }
    defer resp.Body.Close()
    
    // Automatically unmarshal JSON response
    if err := resp.JSONReceive(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

### Custom HTTP Client Configuration

```go
func main() {
    // Custom client with timeout and retry logic
    customClient := &http.Client{
        Timeout: 30 * time.Second,
        Transport: &http.Transport{
            MaxIdleConns:        100,
            MaxIdleConnsPerHost: 10,
            IdleConnTimeout:     90 * time.Second,
        },
    }
    
    resp := httpx.NewRequest(ctx, http.MethodGet, "https://api.example.com/data").
        Client(customClient).  // Use custom client
        AddParam("format", "json").
        AddHeader("User-Agent", "MyApp/1.0").
        Do()
    
    // Handle response...
}
```

### Error Handling and Chaining

```go
func FetchUserData(ctx context.Context, userID string) (*User, error) {
    var user User
    
    resp := httpx.NewRequest(ctx, http.MethodGet, "https://api.example.com/users/"+userID).
        AddHeader("Authorization", "Bearer token123").
        AddParam("include", "profile,settings").
        Do()
    
    // Error is propagated through the chain
    if resp.err != nil {
        return nil, fmt.Errorf("failed to fetch user: %w", resp.err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
    }
    
    if err := resp.JSONReceive(&user); err != nil {
        return nil, fmt.Errorf("failed to decode response: %w", err)
    }
    
    return &user, nil
}
```

## logs（structured logging）

The logs module provides a comprehensive logging system with multiple interfaces, level-based filtering, and flexible output configuration, designed for high-performance applications.

### Features

- **Multiple logging interfaces**: Logger, FormatLogger, CtxLogger
- **Seven log levels**: Trace, Debug, Info, Notice, Warn, Error, Fatal
- **Context-aware logging** with CtxLogger interface
- **Configurable output destinations** (stderr, files, custom writers)
- **Thread-safe operations** for concurrent applications
- **Microsecond precision timestamps**
- **Short file names** in log output for better readability
- **Global and instance-based usage**

### Log Levels and Usage

```go
package main

import (
    "context"
    "os"
    
    "github.com/crazyfrankie/frx/logs"
)

func main() {
    // Set log level (only logs at this level or higher will be output)
    logs.SetLevel(logs.LevelInfo)
    
    // Different log levels (in order of severity)
    logs.Trace("Detailed trace information")     // Lowest level
    logs.Debug("Debug information for developers")
    logs.Info("General information")             // Default level
    logs.Notice("Notable events")
    logs.Warn("Warning messages")
    logs.Error("Error conditions")
    logs.Fatal("Fatal errors - will call os.Exit(1)")  // Highest level
}
```

### Formatted Logging

```go
func main() {
    // Formatted logging with printf-style formatting
    userID := 12345
    userName := "john_doe"
    
    logs.Infof("User %s (ID: %d) logged in successfully", userName, userID)
    logs.Errorf("Failed to process user %d: %v", userID, err)
    logs.Debugf("Processing request with %d items", len(items))
    
    // All format levels available
    logs.Tracef("Trace: %s", "detailed info")
    logs.Debugf("Debug: %s", "debug info")
    logs.Noticef("Notice: %s", "notable event")
    logs.Warnf("Warning: %s", "warning message")
    logs.Fatalf("Fatal: %s", "fatal error")  // Exits program
}
```

### Context-Aware Logging

```go
func ProcessRequest(ctx context.Context, requestID string) {
    // Context-aware logging for request tracing
    logs.CtxInfof(ctx, "Processing request %s", requestID)
    
    // Simulate processing
    if err := doSomeWork(ctx); err != nil {
        logs.CtxErrorf(ctx, "Request %s failed: %v", requestID, err)
        return
    }
    
    logs.CtxInfof(ctx, "Request %s completed successfully", requestID)
}

func doSomeWork(ctx context.Context) error {
    logs.CtxDebugf(ctx, "Starting work processing")
    
    // Simulate work
    select {
    case <-time.After(100 * time.Millisecond):
        logs.CtxDebugf(ctx, "Work completed")
        return nil
    case <-ctx.Done():
        logs.CtxWarnf(ctx, "Work cancelled: %v", ctx.Err())
        return ctx.Err()
    }
}
```

### Custom Logger Configuration

```go
func main() {
    // Redirect logs to a file
    logFile, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        panic(err)
    }
    defer logFile.Close()
    
    logs.SetOutput(logFile)
    logs.SetLevel(logs.LevelDebug)
    
    // Use custom logger instance
    customLogger := logs.DefaultLogger()
    customLogger.SetLevel(logs.LevelWarn)
    customLogger.Info("This won't be logged due to level filtering")
    customLogger.Error("This will be logged")
    
    // Replace default logger
    logs.SetLogger(customLogger)
}
```

### Production Logging Patterns

```go
func HandleAPIRequest(ctx context.Context, req *APIRequest) (*APIResponse, error) {
    requestID := req.ID
    
    logs.CtxInfof(ctx, "API request started: %s", requestID)
    start := time.Now()
    
    defer func() {
        duration := time.Since(start)
        logs.CtxInfof(ctx, "API request completed: %s (took %v)", requestID, duration)
    }()
    
    // Validate request
    if err := validateRequest(req); err != nil {
        logs.CtxWarnf(ctx, "Invalid request %s: %v", requestID, err)
        return nil, err
    }
    
    // Process request
    resp, err := processRequest(ctx, req)
    if err != nil {
        logs.CtxErrorf(ctx, "Failed to process request %s: %v", requestID, err)
        return nil, err
    }
    
    logs.CtxDebugf(ctx, "Request %s processed successfully", requestID)
    return resp, nil
}
```

### Basic Usage

```go
package main

import (
    "github.com/crazyfrankie/frx/logs"
)

func main() {
    logs.SetlogLevel(logs.LevelInfo)
    
    // call log
    logs.Info("Application started")
    logs.Error("Something went wrong", "error", err)
    logs.Debug("Debug information", "data", debugData)
}
```

## errorx（error code management）

The errorx module provides comprehensive error code management with status codes, stack traces, and configurable error registration for structured error handling.

### Features

- Status code support for errors
- Automatic stack trace generation
- Error registration with templates
- Flexible key-value parameters
- Stability tracking for system errors
- Error wrapping capabilities
- **Code generation tool** for automatic error code registration

### Code Generation

The errorx module includes a powerful code generator (`errorx/gen`) that automatically generates `code.Register` calls from YAML configuration files. This approach ensures consistency and reduces manual coding errors.

#### Setting up Code Generation

1. **Create metadata configuration** (`metadata.yaml`):
```yaml
version: 'v1'

# Error code configuration
error_code:
  # Total length of the error code (default: 9)
  total_length: 6
  # Length of app code (default: 1)
  app_length: 1
  # Length of business code (default: 3)
  biz_length: 2
  # Length of sub code (default: 4)
  sub_length: 3

app:
  - name: myapp
    code: 6  # App identifier (1-9)
    business:
      - name: common
        code: 0
      - name: user
        code: 10
      - name: order
        code: 20
```

2. **Create common error codes** (`common.yaml`):
```yaml
error_code:
  - name: CommonNoPermission
    code: 101
    message: no access permission
    no_affect_stability: true

  - name: CommonInternalError
    code: 500
    message: internal server error
    no_affect_stability: false
```

3. **Create business-specific error codes** (`user.yaml`):
```yaml
error_code:
  - name: UserNotFound
    code: 1001
    message: user not found
    description: the specified user does not exist
    no_affect_stability: true

  - name: UserAlreadyExists
    code: 1002
    message: user already exists
    no_affect_stability: true
```

#### Generate Code

Run the generator to create Go code with error registrations:

```bash
go run github.com/crazyfrankie/frx/errorx/gen/code_gen.go \
     --biz user \
     --app-name myapp \
     --app-code 6 \
     --import-path "github.com/crazyfrankie/frx/errorx/code" \
     --output-dir "./generated/user" \
     --script-dir "./config"
```

This generates Go files with automatic error code registration:

```go
// Generated code
package errno

import "github.com/crazyfrankie/frx/errorx/code"

const (
    UserNotFound = int32(610001001)
    UserAlreadyExists = int32(610001002)
)

func init() {
    code.Register(UserNotFound, "user not found", code.WithAffectStability(false))
    code.Register(UserAlreadyExists, "user already exists", code.WithAffectStability(false))
}
```

### Manual Registration (Alternative)

You can also manually register error codes:

```go
package errno

import "github.com/crazyfrankie/frx/errorx/code"

const (
    ErrPermissionDenied = int32(1000001)
    ErrResourceNotFound = int32(1000002)
    ErrInvalidParameter = int32(1000003)
)

func init() {
    code.Register(
        ErrPermissionDenied,
        "unauthorized access: {user}",
        code.WithAffectStability(false),
    )
    
    code.Register(
        ErrResourceNotFound,
        "resource not found: {resource}",
        code.WithAffectStability(true),
    )
}
```

### Using Generated or Registered Errors

Then use the errors in your application:

```go
package main

import (
    "fmt"
	
    "github.com/crazyfrankie/frx/errorx"
    
	"your-project/types/errno"
)

func main() {
    // Create new error with parameters
    err := errorx.New(errno.ErrPermissionDenied, 
        errorx.KV("user", "john_doe"),
        errorx.Extra("request_id", "req-123"),
    )
    
    // Wrap existing error
    originalErr := fmt.Errorf("database connection failed")
    wrappedErr := errorx.WrapByCode(originalErr, errno.ErrResourceNotFound,
        errorx.KV("resource", "user_table"),
    )
    
    // Extract error information
    if statusErr, ok := err.(errorx.StatusError); ok {
        fmt.Printf("Code: %d\n", statusErr.Code())
        fmt.Printf("Message: %s\n", statusErr.Msg())
        fmt.Printf("Affects Stability: %v\n", statusErr.IsAffectStability())
    }
}
```

## idgen（distributed unique ID generator）

The idgen module provides distributed unique ID generation using Redis as the coordination backend, suitable for high-concurrency scenarios.

### Features

- Distributed unique ID generation
- Redis-based coordination
- Batch ID generation support
- Time-based ID structure
- Collision avoidance mechanisms

### Basic Usage

```go
package main

import (
    "context"
    "fmt"
    
    "github.com/redis/go-redis/v9"
	
    "github.com/crazyfrankie/frx/idgen"
)

func main() {
    // Initialize Redis client
    rdb := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    
    // Create ID generator
    generator, err := idgen.New(rdb)
    if err != nil {
        panic(err)
    }
    
    ctx := context.Background()
    
    // Generate single ID
    id, err := generator.GenID(ctx)
    if err != nil {
        panic(err)
    }
    fmt.Printf("Generated ID: %d\n", id)
    
    // Generate multiple IDs (batch)
    ids, err := generator.GenMultiIDs(ctx, 10)
    if err != nil {
        panic(err)
    }
    fmt.Printf("Generated IDs: %v\n", ids)
}
```

## jsoncache（JSON caching）

The jsoncache module provides type-safe JSON caching functionality with Redis backend, supporting generic types for compile-time type safety.

### Features

- Type-safe JSON caching with generics
- Redis backend support
- Automatic JSON marshaling/unmarshaling
- Prefix-based key management
- Error handling with context

### Basic Usage

```go
package main

import (
    "context"
    "fmt"
    
    "github.com/redis/go-redis/v9"
	
    "github.com/crazyfrankie/frx/jsoncache"
)

type User struct {
    ID   int64  `json:"id"`
    Name string `json:"name"`
    Email string `json:"email"`
}

func main() {
    // Initialize Redis client
    rdb := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })
    
    // Create JSON cache for User type
    userCache := jsoncache.New[User]("user:", rdb)
    
    ctx := context.Background()
    
    // Save user to cache
    user := &User{
        ID:   1,
        Name: "John Doe",
        Email: "john@example.com",
    }
    
    err := userCache.Save(ctx, "123", user)
    if err != nil {
        panic(err)
    }
    
    // Get user from cache
    cachedUser, err := userCache.Get(ctx, "123")
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Cached user: %+v\n", cachedUser)
    
    // Delete user from cache
    err = userCache.Delete(ctx, "123")
    if err != nil {
        panic(err)
    }
}
```

## lang（Go language extensions）

The lang module provides utility functions and extensions for common Go programming tasks, organized into several sub-packages.

### Sub-packages

- **conv**: Type conversion utilities
- **ptr**: Pointer manipulation helpers
- **maps**: Map operation utilities
- **sets**: Set data structure operations
- **slices**: Slice manipulation functions
- **crypto**: Cryptographic utilities

### conv - Type Conversion

```go
package main

import (
    "fmt"
	
    "github.com/crazyfrankie/frx/lang/conv"
)

func main() {
    // String to int64 conversion
    num, err := conv.StrToInt64("12345")
    if err != nil {
        panic(err)
    }
    fmt.Printf("Converted number: %d\n", num)
    
    // String to int64 with default value
    numWithDefault := conv.StrToInt64D("invalid", 0)
    fmt.Printf("Number with default: %d\n", numWithDefault)
    
    // Int64 to string
    str := conv.Int64ToStr(12345)
    fmt.Printf("Converted string: %s\n", str)
    
    // Debug JSON conversion
    data := map[string]interface{}{
        "name": "John",
        "age":  30,
    }
    jsonStr := conv.DebugJsonToStr(data)
    fmt.Printf("JSON string: %s\n", jsonStr)
    
    // Bool to int conversion
    intVal := conv.BoolToInt(true)  // returns 1
    fmt.Printf("Bool to int: %d\n", intVal)
}
```

### ptr - Pointer Utilities

```go
package main

import (
    "fmt"
	
    "github.com/crazyfrankie/frx/lang/ptr"
)

func main() {
    // Create pointer from value
    value := 42
    valuePtr := ptr.Of(value)
    fmt.Printf("Pointer value: %d\n", *valuePtr)
    
    // Get value from pointer
    retrievedValue := ptr.From(valuePtr)
    fmt.Printf("Retrieved value: %d\n", retrievedValue)
    
    // Get value from pointer with default
    var nilPtr *int
    defaultValue := ptr.FromOrDefault(nilPtr, 100)
    fmt.Printf("Default value: %d\n", defaultValue)
}
```

## zapx（enhanced Zap logging）

The zapx module provides enhanced logging capabilities built on top of Uber's Zap logger, with additional features like sensitive data masking.

### Features

- Sensitive data masking (e.g., phone numbers)
- Custom core implementation
- Enhanced field processing
- Built on Zap's high-performance logging

### Basic Usage

```go
package main

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
	
    "github.com/crazyfrankie/frx/zapx"
)

func main() {
    // Create standard Zap core
    config := zap.NewProductionConfig()
    core, err := config.Build()
    if err != nil {
        panic(err)
    }
    
    // Wrap with custom core for sensitive data handling
    customCore := zapx.NewCustomCore(core.Core())
    logger := zap.New(customCore)
    
    // Log with sensitive data - phone numbers will be masked
    logger.Info("User login",
        zap.String("user", "john_doe"),
        zap.String("phone", "1234567890"), // Will be masked as "123****890"
        zap.String("action", "login"),
    )
    
    logger.Sync()
}
```

The zapx module automatically masks sensitive fields like phone numbers, replacing the middle digits with asterisks for privacy protection while maintaining log readability.